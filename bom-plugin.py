#!/usr/bin/env python3
import argparse
import re
from collections import defaultdict
import xml.etree.ElementTree as ET

# =============================================================================

__version__ = "1.0"

# =============================================================================


def load_components_from_xml(xml_file):
    """
    Loads component list from an XML file generated by KiCad.
    Returns a list of dicts with component fields.
    """

    known_fields = ("type", "rating", "tolerance", "vendor", "vendor_id")

    # Parse the XML file
    xml  = ET.parse(xml_file)
    root = xml.getroot()

    components = []

    # Get the componets section
    xml_components = root.find("components")
    for xml_comp in xml_components.iter("comp"):

        # Create the component with basic data
        comp = defaultdict(lambda: None)
        comp["ref"] = xml_comp.get("ref")
        comp["value"] = xml_comp.find("value").text

        # Footprint (package)
        footprint = xml_comp.find("footprint").text
        comp["package"] = footprint.rsplit(":", maxsplit=1)[1]

        # "Extra" fields
        xml_fields = xml_comp.find("fields")
        if xml_fields:
            for xml_field in xml_fields.iter("field"):
                field = xml_field.get("name").lower()
                if field in known_fields:
                    comp[field] = xml_field.text

        components.append(comp)

    return components

# =============================================================================


def determine_components_kinds(components):
    """
    Adds to each component "kind" and "index" fileds which content is derived
    from the designator.
    """

    known_kinds = {
        "R": "Resistor",
        "C": "Capacitor",
        "L": "Inductor",
        "D": "Diode",
        "T": "Transistor",
        "Q": "Transistor",
        "X": "Crystal",
        "Y": "Crystal",
        "U": "Chip",
        "F": "Fuse",
        "CON": "Connector",
        "J": "Jumper",
        "TP": "Test point",
        "TR": "Transformer",
        "LED": "LED diode",
        "P": "Pad",
        "H": "Hole",
    }

    expr = re.compile(r"^([A-Za-z]+)([0-9]+)$")

    # Process
    for comp in components:

        match = expr.match(comp["ref"])
        if not match:
            continue

        kind  = match.group(1).upper()
        index = match.group(2)

        if kind in known_kinds:
            comp["kind"] = known_kinds[kind]

        comp["index"] = int(index)

    return components


def group_components(components):
    """
    Groups togeather identical components. Returns a list of component groups.
    """

    ignored_fields = (
        "ref", "index"
    )

    # Create groups
    groups = []
    while(len(components)):

        # Pick a seed
        comp = components[0]
        components.remove(comp)

        # Create a new group
        group = defaultdict(lambda: "")
        group.update({k: v for k, v in comp.items() if k not in ignored_fields})

        # Add matching components to it
        refs = [comp["ref"]]
        for comp in list(components):

            data = {k: v for k, v in comp.items() if k not in ignored_fields}
            if data == group:
                components.remove(comp)
                refs.append(comp["ref"])

        # Finalize group
        group["refs"]  = " ".join(refs)
        group["count"] = len(refs)
        groups.append(group)

    return groups


def sort_groups(groups):
    """
    Sorts component groups basing on the component kind to make the BOM more
    readable.
    """

    order_first = (
        "Resistor",
        "Capacitor",
        "Inductor",
        "Diode",
        "LED diode",
        "Transistor",
        "Chip",
        "Crystal",
        "Connector",
        "Jumper",
    )

    order_last = (
        "Pad",
        "Test point",
        "Hole"
    )

    groups_first = sorted([g for g in groups if g["kind"] in order_first],
                          key=lambda g: order_first.index(g["kind"]))

    groups_mid   = sorted([g for g in groups if g["kind"] not in order_first \
                                            and g["kind"] not in order_last],
                          key=lambda g: g["refs"])

    groups_last  = sorted([g for g in groups if g["kind"] in order_last],
                          key=lambda g: order_last.index(g["kind"]))

    return groups_first + groups_mid + groups_last

# =============================================================================


bom_fields = (
    "refs", "count", "kind", "type", "package", "value", "tolerance", "rating",
    "vendor", "vendor_id",
)


def write_bom_to_xlsx(file_name, bom):
    """
    Writes the BOM to a XLSX file. This function dynamically import the
    "xlsxwriter" package.
    """

    import xlsxwriter

    col_widths = defaultdict(lambda: 10.0)
    col_widths.update({
        "refs":         25.0,
        "count":        6.0,
        "package":      30.0,
        "value":        15.0,
        "vendor":       30.0,
        "vendor_id":    20.0,
    })

    # Create the XLSX
    workbook  = xlsxwriter.Workbook(file_name)
    worksheet = workbook.add_worksheet()

    fmt_header = workbook.add_format({"bold": True, "align": "center"})
    fmt_count  = workbook.add_format({"align": "center"})

    # Prepare columns
    for i, field in enumerate(bom_fields):
        worksheet.set_column(i, i, col_widths[field])

    # Write header
    for i, field in enumerate(bom_fields):
        name = (field[0].upper() + field[1:]).replace("_", " ")
        worksheet.write(0, i, name, fmt_header)

    # Write BOM entries
    for j, group in enumerate(bom):
        for i, field in enumerate(bom_fields):
            if field == "count":
                worksheet.write_number(1+j, i, group[field], fmt_count)
            else:
                worksheet.write_string(1+j, i, group[field])

    workbook.close()


def write_bom_to_csv(file_name, bom):
    """
    Writes the BOM to a text CSV file.
    """

    # Open the CSV file
    with open(file_name, "w") as fp:

        # Write header
        header = ",".join(bom_fields)
        fp.write(header + "\n")

        # Write bom entries
        for group in bom:
            entry = ",".join([str(group[field]) for field in bom_fields])
            fp.write(entry + "\n")

# =============================================================================


def main():

    # Parse arguments
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "xml",
        type=str,
        help="Input XML file from KiCad"
    )

    parser.add_argument(
        "--csv",
        type=str,
        default=None,
        help="Output CSV file"
    )

    parser.add_argument(
        "--xlsx",
        type=str,
        default=None,
        help="Output XLSX file"
    )

    args = parser.parse_args()

    # Load and process components
    print("Loading '{}'".format(args.xml))
    components = load_components_from_xml(args.xml)
    components = determine_components_kinds(components)

    # Create groups & process them
    groups = group_components(components)
    groups = sort_groups(groups)

    # Save BOM to CSV
    if args.csv is not None:
        print("Writing '{}'".format(args.csv))
        write_bom_to_csv(args.csv, groups)

    # Save BOM to XLSX
    if args.xlsx is not None:
        print("Writing '{}'".format(args.xlsx))
        write_bom_to_xlsx(args.xlsx, groups)

# =============================================================================


if __name__ == "__main__":
    main()
